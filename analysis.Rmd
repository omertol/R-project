---
title: "analysis"
output: html_document
date: '2022-06-13'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-packages, message = FALSE}
library(knitr)
library(tidyverse)
library(broom)
library(htmltools)
library(class)
library(data.table)
library(AICcmodavg)
```

```{r load data}
#Load data
list_df <- list.files("./data/spike data", pattern="*.csv", full.names=TRUE)
ldf <- lapply(list_df, read.csv)
```

```{r distance calculations}
if (file.exists("./data/wells distance.csv")){
  
  well_dist <- read.csv("./data/wells distance.csv")
  well_dist <- as.data.frame(lapply(well_dist, as.character))
  well_dist$distance <- as.numeric(well_dist$distance)
  
} else {
  # Create data frame with electrode place when "11" is in (0,0)
  well <- data.frame(matrix(ncol = 3, nrow = 0))
  
  x <- 0
  
  for (i in 1:4){
    y <- 0
    for (j in 1:4){
      well <- rbind(well, c(toString(i * 10 + j), x, y))
      y <- y + 350
    }
    x <- x + 350
  }
  
  colnames(well) <- c("Electrode", "x", "y")
  
  # Create data frame with the distance between every pair of electrodes
  well_dist <- data.frame(as.matrix(ceiling(dist(cbind(well$x, well$y)))))
  colnames(well_dist) <- well$Electrode
  well_dist["Electrode"] <- well$Electrode
  
  well_dist <- well_dist %>% select(1:16) %>% 
    mutate(row.1 = 1:nrow(well_dist)) %>% 
    mutate(elec2 = well_dist$Electrode[row_number()]) %>%
    pivot_longer(names_to="elec1", values_to="distance", cols=1:16) %>% 
    select(elec2, elec1, distance)
  
  # Remove duplicates such as (11, 12), (12, 11)
  well_dist <- well_dist %>% 
    mutate(dup = !duplicated(t(apply(well_dist, 1, sort)))) %>%
    filter(dup) %>% select(c("elec1", "elec2", "distance"))
  
  # Create and save a .csv file for future use
  write.csv(well_dist,"./data/wells distance.csv", row.names = FALSE)
}
```

```{r find wells and treatments, warning=FALSE}
if (file.exists("./data/wells and treatment.csv")){
  well_treat <- read.csv("./data/wells and treatment.csv")
} else {
  # Load one of the data files (arbitrarily) to extract the well information chart
  well_treat <- read.csv(file = "./data/spike data/ac div16(000)_spike_list.csv")
  
  # Find the chart in the file
  rnom <- as.numeric(which(well_treat == "Well Information"))
  well_treat <- fread(file = "./data/spike data/ac div16(000)_spike_list.csv", skip=rnom)
  
  
  # Select only well ID and treatment given
  well_treat <- well_treat[which(well_treat$`Well Information` == "Well" | 
            well_treat$`Well Information` == "Treatment"),]
  
  # Transpose to a longer data frame and fix labeling
  well_treat <- data.frame(t(well_treat[,2:ncol(well_treat)]))
  rownames(well_treat) <- seq(1:nrow(well_treat))
  colnames(well_treat) <- c("Well", "Treatment")
  
  # Filter inactive wells
  well_treat <- well_treat[well_treat$Treatment != "Inactive",]
  
  # Create and save a .csv file for future use
  write.csv(well_treat,"./data/wells and treatment.csv", row.names = FALSE)
}
```

```{r clean the data, message=FALSE}
remove_inactive <- function(data){
  data <- data[c(3,4,5)]
  #only the first 10 minutes
  data<- data %>% filter(data$Time..s.<=600) 
  data <- data[data$Electrode %like% paste(well_treat$Well, collapse = "|"),] 
  data$Time..s. <- as.numeric(data$Time..s.)
  return(data)
}

sep_wells <- function(df){
  df <- separate(df, col = "Electrode",
           into = c("Well", "Electrode"),
           sep = "_")
  df <- drop_na(df)
  return(df)
}

ldf <- lapply(ldf, remove_inactive)
ldf <- lapply(ldf, sep_wells)
```

```{r correlation matrix per time period, message=FALSE}
# Find correlation matrix for each well per each time period
find_corr_mat <- function(file_df, well_id, file_id){
  
  well_df <- filter(file_df, file_df$Well == well_id)
  elec_lst <- split(well_df, f = well_df$Electrode)
  
  # One or less electrodes sent signal for specific well
  if (dim(well_df) == 0 || length(elec_lst) <= 1){
    
    df <- well_dist
    df[,"corr"] <- 0
    df[, "well_id"] <- well_id
    df[, "file_id"] <- file_id
    
    if (length(elec_lst) == 1){
      
      elec <- elec_lst[[1]]$Electrode[1]
      df[which(df$elec2 == df$elec1 & df$elec1 == elec), "corr"] <- 1
      
      }
    
    return(df)
    }
  
  # Prepare data for merge
  neat_df <- function(df){
    name <- df$Electrode[1]
    df[,"id"] <- 1:nrow(df)
    df <- df[,c("id", "Time..s.")]
    colnames(df) <- c("id", name)
    return(df)
    }
  
  elec_lst <- lapply(elec_lst, neat_df)
  df <- Reduce(function(x, y) merge(x, y, by = 'id', all = TRUE), elec_lst)
  
  # Calculate the correlation matrix for this well
  corr_mat <- cor(df[,!(colnames(df) %like% "id")],
                  method = "pearson", 
                  use="pairwise.complete.obs")
  
  corr_mat[is.na(corr_mat)] <- 0
  
  # Convert correlation matrix to df
  corr <- as.data.frame(corr_mat)
  corr$elec2 <- row.names(corr)
  corr <- pivot_longer(data = corr, 
                       names_to = "elec1", 
                       values_to = "corr", 
                       cols=-elec2)
  
  # Add missing electrodes and distance
  corr <- left_join(well_dist, corr, by=c("elec1", "elec2"))

  corr[,"well_id"] <- well_id
  corr[,"file_id"] <- file_id

  return(corr)
  }

# Correlation df for a given well
f1 <- function(well_id) {
  x <- sapply(seq(1:9), function(file_id) find_corr_mat(ldf[[file_id]]
                                                        ,well_id,
                                                        file_id),
              simplify = FALSE)
  return(rbindlist(x))
  }

# Correlation df of every well
corr_df <- rbindlist(sapply(well_treat$Well, f1, simplify = FALSE))
```

```{r mean correlation by distance}
corr_df[is.na(corr_df)] <- 0

corr_df <- corr_df %>% rowwise() %>%
  mutate(treatment = well_treat$Treatment[well_treat$Well == well_id])

# Calculate mean correlation for each distance
corr_df <- corr_df %>% group_by(file_id, treatment, distance) %>% 
  mutate(corr = as.numeric(corr)) %>%
  summarise_at(vars(corr), mean)
```

```{r prepare data for ANOVA tests}
tmp <- corr_df
tmp$file_id <- as.numeric(tmp$file_id)

tmp <- tmp %>% mutate(time_p = case_when(file_id == 1 ~ "Before",
                                         between(file_id, 2, 4) ~ "During",
                                         file_id >= 5 ~ "After"))

tmp <- tmp[, c("treatment", "distance", "corr", "time_p")]
```

```{r additive two-way ANOVA}
two_way <- aov(corr~treatment + time_p,tmp)
summary(two_way)
```

```{r two-way ANOVA with interaction}
interaction <- aov(corr ~ treatment * time_p,tmp)
summary(interaction)
```

```{r AIC's method to find best fitted ANOVA of two}
model.set <- list(two_way, interaction)
model.names <- c("two way", "interaction")

aictab(model.set, modnames = model.names)
```

```{r determine fit of the model, width=2}
two_way_model <- lm(corr ~ treatment * time_p, tmp)
par(mfrow = c(1,2))
fig1 <- plot(two_way_model, c(1,2), add.smooth = FALSE)
```

```{r ANOVA tests with distance}
three_way_interaction <- aov(corr ~ treatment * time_p * as.factor(distance), tmp)
summary(three_way_interaction)

two_way_distance <- aov(corr ~ treatment * time_p + as.factor(distance), tmp)
summary(two_way_distance)
```

```{r AIC's method to find best fitted ANOVA of four}
model.set <- list(two_way, interaction, three_way_interaction, two_way_distance)
model.names <- c("two way anova", "interaction", "three way anova", "two way with distance")

aictab(model.set, modnames = model.names)
```

```{r determine fit of the model}
two_way_distance_model <- lm(corr ~ treatment * time_p + distance, tmp)
par(mfrow = c(1,2))
fig2 <- plot(two_way_distance_model, c(1,2), add.smooth = FALSE)
```

```{r Tukeyâ€™s Test for multiple comparisons}
tbl1 <- as.data.frame(TukeyHSD(two_way_distance, which = c("treatment"))[[1]])

tbl2 <- as.data.table(TukeyHSD(two_way_distance, which = c("treatment:time_p"))[[1]], 
                                  keep.rownames = TRUE)

tbl2 <- separate(tbl2,
                             col = 1,
                             into = c("t1", "t2"),
                             sep = "-") %>% 
  separate(col = 2,
           into = c("treatment2", "time2"),
           sep = ":") %>% 
  separate(col = 1,
           into= c("treatment1", "time1"), 
           sep = ":")

tbl2 <- tbl2[treatment1 == treatment2 & time1 == "Before" & time2 == "After",
                                     c(1,2,4,5,6,7,8)]
tbl1
tbl2
```
