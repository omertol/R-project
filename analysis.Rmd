---
title: "analysis"
output: html_document
date: '2022-06-13'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load-packages, message = FALSE}
library(knitr)
library(tidyverse)
library(broom)
library(htmltools)
library(class)
library(data.table)
```

```{r load data}
#Load data
list_df <- list.files("./data/spike data", pattern="*.csv", full.names=TRUE)
ldf <- lapply(list_df, read.csv)
```

```{r distance calculations}
if (file.exists("./data/wells distance.csv")){
  well_dist <- read.csv("./data/wells distance.csv")
  well_dist <- as.data.frame(lapply(well_dist, as.character))
  well_dist$distance <- as.numeric(well_dist$distance)
} else {
  # Create data frame with electrode place when "11" is in (0,0)
  well <- data.frame(matrix(ncol = 3, nrow = 0))
  
  x <- 0
  
  for (i in 1:4){
    y <- 0
    for (j in 1:4){
      well <- rbind(well, c(toString(i * 10 + j), x, y))
      y <- y + 350
    }
    x <- x + 350
  }
  
  colnames(well) <- c("Electrode", "x", "y")
  
  # Create data frame with the distance between every pair of electrodes
  well_dist <- data.frame(as.matrix(ceiling(dist(cbind(well$x, well$y)))))
  colnames(well_dist) <- well$Electrode
  well_dist["Electrode"] <- well$Electrode
  
  well_dist <- well_dist %>% select(1:16) %>% 
    mutate(row.1 = 1:nrow(well_dist)) %>% 
    mutate(elec2 = well_dist$Electrode[row_number()]) %>%
    gather(elec1, distance, 1:16) %>% 
    select(elec2, elec1, distance)
  
  # Remove duplicates such as (11, 12), (12, 11)
  well_dist <- well_dist %>% 
    mutate(dup = !duplicated(t(apply(well_dist, 1, sort)))) %>%
    filter(dup) %>% select(c("elec1", "elec2", "distance"))
  
  # Create and save a .csv file for future use
  write.csv(well_dist,"./data/wells distance.csv", row.names = FALSE)
}
```

```{r find wells and treatments, warning=FALSE}
if (file.exists("./data/wells and treatment.csv")){
  well_treat <- read.csv("./data/wells and treatment.csv")
} else {
  # Load one of the data files (arbitrarily) to extract the well information chart
  well_treat <- read.csv(file = "./data/spike data/ac div16(000)_spike_list.csv")
  
  # Find the chart in the file
  rnom <- as.numeric(which(well_treat == "Well Information"))
  well_treat <- fread(file = "./data/spike data/ac div16(000)_spike_list.csv", skip=rnom)
  
  
  # Select only well ID and treatment given
  well_treat <- well_treat[which(well_treat$`Well Information` == "Well" | 
            well_treat$`Well Information` == "Treatment"),]
  
  # Transpose to a longer data frame and fix labeling
  well_treat <- data.frame(t(well_treat[,2:ncol(well_treat)]))
  rownames(well_treat) <- seq(1:nrow(well_treat))
  colnames(well_treat) <- c("Well", "Treatment")
  
  # Filter inactive wells
  well_treat <- well_treat[well_treat$Treatment != "Inactive",]
  
  # Create and save a .csv file for future use
  write.csv(well_treat,"./data/wells and treatment.csv", row.names = FALSE)
}
```

```{r clean the data, message=FALSE}
remove_inactive <- function(data){
  data <- data[data$Electrode %like% paste(well_treat$Well, collapse = "|"),] 
  #only the first 10 minutes
  data<- data %>% filter(data$Time..s.<=600) 
  data$Time..s. <- as.numeric(data$Time..s.)
  return(data)
}

sep_wells <- function(df){
  df_res <- df[c(3,4,5)]
  df_res <- separate(df_res, col = "Electrode",
           into = c("Well", "Electrode"),
           sep = "_")
  df_res <- drop_na(df_res)
  return(df_res)
}

ldf <- lapply(ldf, remove_inactive)
ldf <- lapply(ldf, sep_wells)
```

```{r correlation matrix per time period, message=FALSE}
# Find correlation matrix for each well per each time period
find_corr_mat <- function(file_df, well_id, file_id){
  
  well_df <- filter(file_df, file_df$Well == well_id)
  elec_lst <- split(well_df, f = well_df$Electrode)
  
  if (dim(well_df[1]) == 0 || length(elec_lst) <= 1){
    df <- as.data.frame(matrix(c(NA, NA, NA, well_id, file_id), ncol = 5, nrow = 1))
    colnames(df) <- c("elec2", "elec1", "corr", "well_id", "file_id")
    return(df)
  }
  
  # Prepare data for merge
  neat_df <- function(df){
    name <- df$Electrode[1]
    df[,"id"] <- 1:nrow(df)
    df <- df[,c("id", "Time..s.")]
    colnames(df) <- c("id", name)
    return(df)
  }
  
  elec_lst <- lapply(elec_lst, neat_df)
  df <- Reduce(function(x, y) merge(x, y, by = 'id', all = TRUE), elec_lst)
  
  # Calculate the correlation matrix for this well
  corr_mat <- cor(df[,!(colnames(df) %like% "id")],
                  method = "pearson", 
                  use="pairwise.complete.obs")
  
  corr_mat[is.na(corr_mat)] <- 0
  
  # Convert correlation matrix to df
  corr <- as.data.frame(corr_mat)
  corr$elec2 <- row.names(corr)
  corr <- gather(data = corr, key = "elec1", value = "corr", -elec2)
  corr[,"well_id"] <- well_id
  corr[,"file_id"] <- file_id
  return(corr)
}

# Correlation df for a given well
f1 <- function(well_id) {
  x <- sapply(seq(1:9), function(file_id) find_corr_mat(ldf[[file_id]]
                                                        ,well_id,
                                                        file_id),
              simplify = FALSE)
  return(rbindlist(x))
  }

# Correlation df of every well
corr_df <- rbindlist(sapply(well_treat$Well, f1, simplify = FALSE))
```

```{r mean correlation by distance}
# Add the distance column to the correlation data frame
corr_df <- right_join(well_dist, corr_df, by=c("elec1", "elec2"))

corr_df <- corr_df %>% rowwise() %>%
  mutate(treatment = well_treat$Treatment[well_treat$Well == well_id])

# Calculate mean correlation for each distance
corr_df <- corr_df %>% group_by(file_id, treatment, distance) %>% 
  mutate(corr = as.numeric(corr)) %>%
  summarise_at(vars(corr), mean)
```
